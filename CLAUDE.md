# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

**EARL** (Engineering Assistant Relay for LLMs) is a Ruby CLI bot that connects to Mattermost via WebSocket, listens for messages in configured channels, spawns Claude Code CLI sessions, and streams responses back as threaded replies.

This is a standalone Ruby gem (`earl-bot`) with one runtime dependency (`websocket-client-simple`).

Reference implementation: [claude-threads](https://github.com/anneschuth/claude-threads) (TypeScript/Bun).

## Environments

EARL supports dev and prod running simultaneously with separate config, bots, and channels.

| | Production | Development |
|--|-----------|-------------|
| **Config root** | `~/.config/earl/` | `~/.config/earl-dev/` |
| **Repo checkout** | `~/.local/share/earl/` (stable clone) | `~/Code/ericboehs/earl/` (working copy) |
| **Start command** | `earl` (from `~/bin/earl`) | `exe/earl` (from repo, direnv loads `.envrc`) |
| **Bot account** | `@earl` | `@earl-dev` |
| **Detection** | `EARL_ENV` unset or `production` | `EARL_ENV=development` via direnv |

Config root is derived from `EARL_ENV` via `Earl.config_root`. All file paths (sessions, memory, heartbeats, MCP configs, allowed tools) are relative to the config root.

## Running

```bash
# Development (from repo checkout, direnv sets EARL_ENV=development)
exe/earl

# Production (from ~/bin wrapper, uses ~/.local/share/earl/)
earl

# Restart a running instance (sends SIGHUP via PID file)
exe/earl restart   # dev
earl restart       # prod
```

Requires env vars (see `<config_root>/env` or `.envrc`):
- `EARL_ENV` — Environment: `production` (default) or `development`
- `MATTERMOST_URL` — Mattermost server URL
- `MATTERMOST_BOT_TOKEN` — Bot authentication token
- `MATTERMOST_BOT_ID` — Bot user ID (to ignore own messages)
- `EARL_CHANNEL_ID` — Default channel to listen in
- `EARL_CHANNELS` — Multi-channel config (comma-separated `channel_id:/working/dir` pairs, e.g. `chan1:/path1,chan2:/path2`)
- `EARL_ALLOWED_USERS` — Comma-separated usernames allowed to interact
- `EARL_SKIP_PERMISSIONS` — Set to `true` to use `--dangerously-skip-permissions` instead of MCP approval
- `EARL_CLAUDE_HOME` — Custom HOME for Claude subprocesses (default: `<config_root>/claude-home`)

Optional config files (under `<config_root>/`):
- `heartbeats.yml` — Heartbeat schedule definitions
- `memory/` — Persistent memory files (SOUL.md, USER.md, daily notes)
- `earl.pid` — PID file for running instance (used by `earl restart`)
- `sessions.json` — Session persistence store
- `allowed_tools/` — Per-thread tool approval lists
- `tmux_sessions.json` — Tmux session metadata persistence
- `claude-home/` — Default working directory for Claude subprocesses (project-level CLAUDE.md lives here)
- `env` — Environment variables for launchd/wrapper (secrets, config)
- `logs/` — stdout/stderr logs when running via launchd

## Setup

```bash
exe/earl-install
```

On first run this creates env files for both environments — fill in secrets and re-run. On subsequent runs it:
1. Creates config dirs for both dev (`~/.config/earl-dev/`) and prod (`~/.config/earl/`)
2. Copies default Claude project config to both `claude-home/` dirs
3. Clones the repo to `~/.local/share/earl/` (prod)
4. Creates `~/bin/earl` wrapper script (prod)

### Claude Project Directory

Claude subprocesses spawned by EARL use `<config_root>/claude-home/` as their default working directory (when no channel-specific working dir is configured). This lets EARL have its own project-level `CLAUDE.md` without polluting other repos. Claude uses the real `$HOME` for global config and credentials. Override with `EARL_CLAUDE_HOME` env var.

## Architecture

```
exe/
  earl                          # Entry point
  earl-install                  # Setup script: config dirs, prod clone, ~/bin/earl wrapper
  earl-permission-server        # MCP permission server (spawned by Claude CLI as subprocess)
bin/
  ci                            # CI pipeline runner
  claude-context                # Context window usage helper (spawned by !context command)
  claude-usage                  # Claude usage helper (spawned by !usage command)
  coverage                      # Coverage report generator
~/bin/earl                      # Production wrapper (generated by exe/earl-install)
lib/
  earl.rb                       # Module root, requires, shared logger, env/config_root
  earl/
    version.rb                  # Earl::VERSION
    config.rb                   # ENV-based configuration
    logging.rb                  # Shared logging mixin
    formatting.rb               # Shared number formatting helpers
    permission_config.rb        # Shared permission env builder
    tool_input_formatter.rb     # Shared tool display formatting
    mattermost.rb               # WebSocket + REST API client
    mattermost/api_client.rb    # HTTP client with retry logic
    claude_session.rb           # Single Claude CLI process wrapper
    claude_session/
      stats.rb                  # Usage statistics tracking (Struct)
    session_manager.rb          # Maps thread IDs -> Claude sessions
    session_manager/
      persistence.rb            # Session pause/resume persistence
      session_creation.rb       # Session creation and resume logic
    session_store.rb            # Persists session metadata to disk
    streaming_response.rb       # Mattermost post lifecycle (create/update/debounce)
    message_queue.rb            # Per-thread message queuing for busy sessions
    command_parser.rb           # Parses !commands from message text
    command_executor.rb         # Executes !help, !stats, !stop, !kill, !escape, !compact, !cd, !permissions, !heartbeats, !usage, !context, !sessions, !session, !update, !restart, !spawn
    command_executor/
      constants.rb              # Help table, dispatch map, script paths
      lifecycle_handler.rb      # !restart, !update handlers
      heartbeat_display.rb      # !heartbeats display formatting
      session_handler.rb        # !sessions, !session subcommand handlers
      spawn_handler.rb          # !spawn handler
      stats_formatter.rb        # !stats display formatting
      usage_handler.rb          # !usage, !context handlers
    question_handler.rb         # AskUserQuestion tool -> emoji reaction flow
    question_handler/
      question_posting.rb       # Question post creation and cleanup
    runner.rb                   # Main event loop, wires everything together
    runner/
      idle_management.rb        # Idle session detection and cleanup
      lifecycle.rb              # Startup, shutdown, restart logic
      message_handling.rb       # Incoming message processing
      reaction_handling.rb      # Emoji reaction event processing
      response_lifecycle.rb     # Claude response streaming callbacks
      service_builder.rb        # Dependency construction
      startup.rb                # Channel resolution, initial logging
      thread_context_builder.rb # Thread transcript for new sessions
    cron_parser.rb              # Minimal 5-field cron expression parser
    heartbeat_config.rb         # Loads heartbeat definitions from YAML
    heartbeat_scheduler.rb      # Runs heartbeat tasks on cron/interval/one-shot schedules; auto-reloads config
    heartbeat_scheduler/
      config_reloading.rb       # Auto-reload config on file change
      execution.rb              # Heartbeat task execution
      heartbeat_state.rb        # Per-heartbeat mutable state (Data.define)
      lifecycle.rb              # Start/stop/pause/resume lifecycle
    tmux.rb                     # Tmux shell wrapper (list sessions/panes, capture, send-keys, wait-for-text)
    tmux/
      parsing.rb                # Tmux output parsing helpers
      processes.rb              # Process detection on TTYs
      sessions.rb               # Session/pane listing
    tmux_session_store.rb       # JSON persistence for tmux session metadata
    tmux_monitor.rb             # Background poller: detects questions/permissions in tmux panes, forwards via Mattermost reactions
    tmux_monitor/
      alert_dispatcher.rb       # Mattermost alert posting
      output_analyzer.rb        # Pane output state detection
      permission_forwarder.rb   # Permission prompt forwarding
      question_forwarder.rb     # Question prompt forwarding
    safari_automation.rb        # Safari AppleScript automation for GitHub PAT creation
    mcp/
      config.rb                 # MCP server ENV-based config
      handler_base.rb           # Base class for MCP tool handlers
      server.rb                 # JSON-RPC 2.0 MCP server over stdio
      approval_handler.rb       # Permission approval via Mattermost reactions
      memory_handler.rb         # save_memory / search_memory MCP tools
      heartbeat_handler.rb      # manage_heartbeat MCP tool (CRUD heartbeat schedules)
      tmux_handler.rb           # manage_tmux_sessions MCP tool (list, capture, approve, spawn, kill)
      github_pat_handler.rb     # GitHub PAT creation via Safari automation
    memory/
      store.rb                  # File I/O for persistent memory (markdown files)
      prompt_builder.rb         # Builds system prompt from memory store
```

### Message Flow

```
User posts in channel
  -> Mattermost WebSocket 'posted' event
  -> Runner checks allowlist
  -> CommandParser checks for !commands
     -> If command: CommandExecutor handles it (!help, !stats, !kill, !cd, !restart, !sessions, !session, !spawn, etc.)
     -> If message: MessageQueue serializes per-thread
  -> SessionManager gets/creates ClaudeSession for thread
     -> Resumes from session store if available
     -> Builds MCP config for permission approval
     -> Injects memory context via --append-system-prompt
  -> For new sessions in existing threads: fetches Mattermost thread transcript for context
  -> session.send_message(text) writes JSON to Claude stdin
  -> Claude stdout emits events (assistant, result, system)
     -> on_text: StreamingResponse creates POST or debounced PUT
     -> on_tool_use: StreamingResponse shows tool icon + detail
     -> on_tool_use(AskUserQuestion): QuestionHandler posts options, waits for reaction
     -> on_complete: final PUT with stats footer, process next queued message
  -> User sees threaded reply in Mattermost
```

### Key Details

- **WebSocket events**: `data.post` is a nested JSON string requiring double-parse
- **Claude CLI**: spawned with `--input-format stream-json --output-format stream-json --verbose`
- **Permissions**: Default uses `--permission-prompt-tool mcp__earl__permission_prompt --mcp-config <path>` for interactive approval via Mattermost reactions. Set `EARL_SKIP_PERMISSIONS=true` for `--dangerously-skip-permissions`.
- **Streaming**: first text chunk creates a POST, subsequent chunks do PUT with 300ms debounce
- **Sessions**: follow-up messages in same thread reuse the same Claude process (same context window)
- **Session persistence**: sessions are saved to `~/.config/earl/sessions.json` and resumed on restart
- **Shutdown**: SIGINT/SIGTERM triggers graceful shutdown: stops background services, pauses all sessions, then exits.
- **Restart**: `!restart` (Mattermost), `SIGHUP` (signal), or `earl restart` (CLI). In prod, runs `git pull --ff-only` first (non-fatal on failure). Pauses sessions, then `Kernel.exec` replaces the process in-place. Sessions resume on boot. PID file at `<config_root>/earl.pid` enables CLI restart.
- **Memory**: Persistent facts stored as markdown in `~/.config/earl/memory/`. Injected into Claude sessions via `--append-system-prompt`. Claude can save/search via MCP tools.
- **Heartbeats**: Scheduled tasks (cron/interval/one-shot via `run_at`) that spawn Claude sessions, posting results to configured channels. One-off tasks (`once: true`) auto-disable after execution. Config auto-reloads on file change. Claude can manage schedules via the `manage_heartbeat` MCP tool.
- **Tmux MCP tool**: `manage_tmux_sessions` tool exposes tmux session control to spawned Claude sessions. Actions: list, capture, status, approve, deny, send_input, spawn (requires Mattermost confirmation), kill.
- **Tmux Session Supervisor**: Mattermost becomes a control plane for all running Claude sessions (both EARL-managed and standalone tmux-based). `!sessions` lists all tmux panes running Claude with per-pane status. Detection uses `list_all_panes` + `claude_on_tty?` (ps-based TTY check). `!session <name> approve/deny` remotely handles Claude CLI permission dialogs. `!session <name> status` shows AI-summarized state. `!spawn "prompt"` creates new Claude sessions in tmux. TmuxMonitor runs a background poller that detects questions and permission prompts in tmux panes and forwards them to Mattermost for reaction-based handling.
- **Thread context**: When a Claude session is first created for a thread that already has messages (e.g., from `!` commands and EARL replies), the Mattermost thread transcript (up to 20 posts) is prepended so Claude has context for follow-up messages.

## Testing with Mattermost MCP

A Mattermost MCP server can be configured in `.mcp.json` (gitignored) for integration testing while EARL is running.

**Available tools:** `mcp__mattermost__send_message`, `mcp__mattermost__get_channel_messages`, `mcp__mattermost__search_messages`, `mcp__mattermost__list_channels`, etc.

**Example workflow — send a message and check EARL's reply:**
```
# Send a message to EARL (starts a new thread)
mcp__mattermost__send_message(channel_id: "<your-channel-id>", message: "Hello EARL")

# Or reply in an existing thread
mcp__mattermost__send_message(channel_id: "<your-channel-id>", message: "!usage", reply_to: "<root_post_id>")

# Read recent messages to see EARL's response
mcp__mattermost__get_channel_messages(channel_id: "<your-channel-id>", limit: 5)
```

## Development Commands

- `bin/ci` — Run full CI pipeline
- `rubocop` — Ruby style checking
- `rubocop -A` — Auto-fix style violations
- `bundle exec rake test` — Run test suite

## Code Quality

This project uses **vanilla RuboCop and Reek** with minimal global configuration. Do not:

- Add `# rubocop:disable` inline comments — fix the code instead
- Add `# :reek:` inline annotations — refactor to eliminate the smell
- Add per-class or per-method exclusions to `.rubocop.yml` or `.reek.yml`
- Raise thresholds or disable detectors to work around warnings

Global Reek overrides (in `.reek.yml`):
- `UtilityFunction: public_methods_only: true` — private helpers may operate on other objects
- `TooManyStatements: max_statements: 10` — raised from default 5
- `TooManyMethods: max_methods: 20` — raised from default 15

If a linter flags something, refactor the code to satisfy it. Common Reek fixes:
- **FeatureEnvy**: Extract accessed fields into locals, use `values_at`, or move logic onto the data object
- **TooManyStatements**: Extract helper methods to stay under 10 statements
- **DuplicateMethodCall**: Extract repeated calls into a local variable
- **ControlParameter**: Replace with predicates, hash dispatch, or polymorphism
- **DataClump**: Bundle traveling parameters into Structs or Data.define objects

## Commit Messages

This project follows [Conventional Commits](https://www.conventionalcommits.org/) specification.
